---
- name: Start from a clean slate
  become: true
  file:
    path={{ item }}
    state=absent
  with_items:
    - "{{ project_backup }}"
    - "{{ project_newinstall_tmp }}"

- name: Stat current installation
  stat:
    path={{ project_root  }}
  register: install_check

- name: Create temporary application root for new install
  become: true
  file:
    path={{ project_newinstall_tmp }}
    state=directory

- name: Rsync application files to temporary application root
  become: true
  synchronize:
    src: "../../../../"
    dest: "{{ project_newinstall_tmp }}"
    delete: true
    recursive: true
    rsync_opts:
      - "--cvs-exclude"

- name: Salvage virtualenv from previous installation
  become: true
  command: cp -r {{ project_root }}/venv {{ project_newinstall_tmp }}/venv
  when: install_check.stat.isdir is defined and install_check.stat.isdir

- name: Stat venv
  stat:
    path={{ project_newinstall_tmp }}/venv
  register: venv_check

- name: Create python3 virtualenv
  shell: "python3 -m venv {{ project_newinstall_tmp }}/venv"
  become: true
  when: venv_check.stat.isdir is not defined

- name: Set permissions on new temporary application root
  become: true
  file:
    path: "{{ project_newinstall_tmp }}"
    recurse: yes
    owner: "{{ project_user }}"
    group: "{{ project_group }}"

- name: Upgrade pip and setuptools
  become: true
  become_user: "{{ project_user }}"
  pip:
    name: "{{ item }}"
    extra_args: --upgrade
    virtualenv: "{{ project_newinstall_tmp }}/venv"
  with_items:
    - pip
    - setuptools

- name: Install python3 application packages
  become: true
  become_user: "{{ project_user }}"
  pip:
    requirements={{ project_newinstall_tmp }}/requirements.txt
    virtualenv={{ project_newinstall_tmp }}/venv

- name: Back up current installation
  become: true
  when: install_check.stat.exists
  command: mv {{ project_root }} {{ project_backup }}

- name: Activate new installation
  become: true
  command: mv {{ project_newinstall_tmp }} {{ project_root }}

- name: Stat global config
  stat:
    path="/etc/medley.conf"
  register: global_config_check

- name: Place config file in /etc
  become: true
  command: cp medley.conf.example /etc/medley.conf
  args:
    chdir: "{{ project_root }}"
  when: global_config_check.stat.exists == False

- name: Install medley systemd service files
  become: true
  copy: src={{ item }} dest=/etc/systemd/system/
  with_items:
    - files/medley.service
    - files/medley-geodb.service
    - files/medley-geodb.timer
    - files/medley-db-maintenance.service
    - files/medley-db-maintenance.timer
    - files/medley-fs-maintenance.service
    - files/medley-fs-maintenance.timer
    - files/medley-headlines.service
    - files/medley-headlines.timer

- name: Enable medley systemd service
  become: true
  systemd:
    daemon_reload: yes
    enabled: yes
    masked: no
    name: medley
    state: restarted

- name: Enable medley systemd timers
  become: true
  systemd:
    daemon_reload: yes
    enabled: yes
    masked: no
    name: "{{ item }}"
    state: started
  with_items:
    - medley-geodb.timer
    - medley-db-maintenance.timer
    - medley-fs-maintenance.timer
    - medley-headlines.timer

- name: Check server availability
  uri:
    url: "http://localhost:8085/"
    status_code: 200
  register: this
  until: this.status == 200
  retries: 6
  delay: 10
